import os, time, threading, subprocess, shutil, glob, html, re, json
from flask import Flask, render_template_string, send_file, request, redirect, url_for, abort, jsonify

# --- Config ---
SESSIONS_DIR = "/home/pi/timelapse/sessions"
IMAGES_DIR   = "/home/pi/timelapse/images"
SCHEDULE_FILE = "/home/pi/timelapse/schedule.json"
os.makedirs(SESSIONS_DIR, exist_ok=True)
os.makedirs(IMAGES_DIR, exist_ok=True)

CAMERA_STILL = shutil.which("rpicam-still") or "/usr/bin/rpicam-still"
CAMERA_HELLO = shutil.which("rpicam-hello") or "/usr/bin/rpicam-hello"

CAPTURE_WIDTH   = "1296"
CAPTURE_HEIGHT  = "972"
CAPTURE_QUALITY = "90"
CAPTURE_INTERVAL_SEC = 10

DEFAULT_FPS = 24
FPS_CHOICES = [10, 24, 30]

app = Flask(__name__)

# --- State ---
_timelapse_running = False
_timelapse_thread  = None
_current_session   = None
_interval_sec      = CAPTURE_INTERVAL_SEC
_video_jobs        = {}   # sid -> {"status":"running|done|error","progress":int,"msg":str,"fps":int}

_schedule_lock = threading.Lock()
_schedule = None  # {"start": epoch, "end": epoch, "interval":int, "fps":int, "status": "...", "session": str}

# --- Helpers ---
def list_sessions():
    sess = [d for d in os.listdir(SESSIONS_DIR) if os.path.isdir(os.path.join(SESSIONS_DIR, d))]
    sess.sort(key=lambda s: os.path.getmtime(os.path.join(SESSIONS_DIR, s)))
    return sess

def session_images(session_path):
    return sorted(glob.glob(os.path.join(session_path, "*.jpg")))

def session_meta():
    items = []
    for s in list_sessions():
        p = os.path.join(SESSIONS_DIR, s)
        imgs = session_images(p)
        items.append({
            "name": s,
            "has_images": len(imgs) > 0,
            "has_video": os.path.exists(os.path.join(p, "timelapse.mp4")),
        })
    return items

def safe_session_name(raw):
    name = re.sub(r'[^A-Za-z0-9_-]+', '_', (raw or "").strip()).strip('_')
    if not name:
        name = time.strftime("session_%Y%m%d_%H%M%S")
    if re.fullmatch(r'\d+', name):
        name = "session_" + name
    return name

def unique_session_name(base):
    dst = base
    i = 1
    while os.path.exists(os.path.join(SESSIONS_DIR, dst)):
        i += 1
        dst = f"{base}-{i}"
    return dst

def capture_one(path, timeout=20):
    cmd = [
        CAMERA_STILL, "-n", "-t", "1200",
        "--width", CAPTURE_WIDTH, "--height", CAPTURE_HEIGHT,
        "--quality", CAPTURE_QUALITY, "-o", path
    ]
    return subprocess.run(cmd, capture_output=True, text=True, timeout=timeout)

def save_schedule():
    with _schedule_lock:
        data = _schedule
    tmp = SCHEDULE_FILE + ".tmp"
    try:
        with open(tmp, "w") as f:
            json.dump(data, f)
        os.replace(tmp, SCHEDULE_FILE)
    except Exception:
        pass

def load_schedule():
    global _schedule
    try:
        with open(SCHEDULE_FILE, "r") as f:
            _schedule = json.load(f)
    except Exception:
        _schedule = None

# --- Timelapse ---
def _timelapse_loop():
    global _current_session
    while _timelapse_running and _current_session:
        ts = time.strftime("%Y%m%d-%H%M%S")
        img_path = os.path.join(_current_session, f"{ts}.jpg")
        try:
            capture_one(img_path, timeout=max(8, _interval_sec + 5))
        except Exception as e:
            print("[ERROR] capture:", e)
        time.sleep(max(1, _interval_sec))

def start_timelapse(interval_sec=None):
    global _timelapse_running, _timelapse_thread, _current_session, _interval_sec
    if _timelapse_running:
        return
    if interval_sec:
        _interval_sec = max(1, int(interval_sec))
    ts = time.strftime("%Y%m%d-%H%M%S")
    sess_name = f"session-{ts}"
    _current_session = os.path.join(SESSIONS_DIR, sess_name)
    os.makedirs(_current_session, exist_ok=True)
    _timelapse_running = True
    _timelapse_thread = threading.Thread(target=_timelapse_loop, daemon=True)
    _timelapse_thread.start()

def stop_timelapse():
    global _timelapse_running, _current_session
    _timelapse_running = False
    _current_session = None

def current_session_name():
    return os.path.basename(_current_session) if _current_session else None

# --- Video encode (background with progress) ---
def ffmpeg_create_video(sid, path, fps):
    out_path = os.path.join(path, "timelapse.mp4")
    imgs = session_images(path)
    if not imgs:
        _video_jobs[sid] = {"status": "error", "progress": 0, "msg": "No images", "fps": fps}
        return
    _video_jobs[sid] = {"status": "running", "progress": 0, "fps": fps}
    cmd = [
        "ffmpeg", "-y", "-hide_banner", "-loglevel", "info",
        "-framerate", str(fps), "-pattern_type", "glob",
        "-i", os.path.join(path, "*.jpg"),
        "-c:v", "libx264", "-pix_fmt", "yuv420p", out_path
    ]
    try:
        proc = subprocess.Popen(cmd, stderr=subprocess.PIPE, text=True)
        total = len(imgs)
        for line in proc.stderr:
            m = re.search(r"frame=\s*(\d+)", line)
            if m:
                done = int(m.group(1))
                pct = min(100, int(done / max(1, total) * 100))
                _video_jobs[sid]["progress"] = pct
        proc.wait()
        if proc.returncode == 0:
            _video_jobs[sid] = {"status": "done", "progress": 100, "fps": fps}
        else:
            _video_jobs[sid] = {"status": "error", "progress": 0, "msg": "ffmpeg failed", "fps": fps}
    except Exception as e:
        _video_jobs[sid] = {"status": "error", "progress": 0, "msg": str(e), "fps": fps}

# --- Simple scheduler thread ---
def _scheduler_loop():
    global _schedule
    while True:
        time.sleep(2)
        load_schedule()
        with _schedule_lock:
            sch = _schedule

        if not sch or sch.get("status") in ("done", "canceled"):
            continue

        now = int(time.time())

        # Start window
        if sch["status"] == "armed" and now >= sch["start"] and now < sch["end"]:
            start_timelapse(sch.get("interval", CAPTURE_INTERVAL_SEC))
            with _schedule_lock:
                sch["session"] = current_session_name()
                sch["status"]  = "running"
                _schedule = sch
                save_schedule()
            continue

        # End window reached
        if sch["status"] in ("armed", "running") and now >= sch["end"]:
            if _timelapse_running:
                started_sid = current_session_name()
                stop_timelapse()
                if not sch.get("session"):
                    with _schedule_lock:
                        sch["session"] = started_sid
                        _schedule = sch
                        save_schedule()
            sid = sch.get("session")
            if sid:
                path = os.path.join(SESSIONS_DIR, sid)
                if os.path.isdir(path):
                    with _schedule_lock:
                        sch["status"] = "encoding"
                        _schedule = sch
                        save_schedule()
                    threading.Thread(
                        target=_encode_and_mark_done, args=(sid, path, sch.get("fps", DEFAULT_FPS)), daemon=True
                    ).start()
            else:
                with _schedule_lock:
                    sch["status"] = "done"
                    _schedule = sch
                    save_schedule()

def _encode_and_mark_done(sid, path, fps):
    global _schedule
    ffmpeg_create_video(sid, path, fps)
    with _schedule_lock:
        if _schedule:
            _schedule["status"] = "done"
            save_schedule()

# Start scheduler thread
threading.Thread(target=_scheduler_loop, daemon=True).start()

# --- Template ---
INDEX_HTML = """
<!doctype html>
<html><head><title>Pi Timelapse</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
:root { --btn-bg:#fff; --btn-fg:#000; --btn-bd:#999; }
body { font-family:-apple-system,system-ui,Segoe UI,Roboto,sans-serif; max-width:780px; margin:2rem auto; padding:0 1rem; }
h1 { margin-bottom:.2rem; }
section { margin:1rem 0; padding:1rem; border:1px solid #ddd; border-radius:12px; }
button, .btn {
  display:inline-block; text-decoration:none; padding:.65rem 1rem; margin:.2rem;
  border-radius:12px; border:1px solid var(--btn-bd); background:var(--btn-bg); color:var(--btn-fg);
  font-size:16px; line-height:1; -webkit-appearance:none; appearance:none;
}
select, input[type=number], input[type=text], input[type=datetime-local] {
  padding:.45rem .6rem; border-radius:10px; border:1px solid #bbb; font-size:16px;
}
.thumb { width:240px; height:180px; object-fit:cover; border:1px solid #ccc; border-radius:8px; }
.session { border:1px dashed #bbb; border-radius:12px; padding:.75rem; margin:.75rem 0; }
.progress { width:100%; height:12px; background:#eee; border-radius:6px; overflow:hidden; margin-top:.4rem; }
.progress > div { height:100%; background:#3a86ff; width:0%; transition:width .3s ease; }
small.muted { color:#666; }
</style>
</head><body>
<h1>Pi Timelapse</h1>
<p>Status: <strong>{{ "Running" if running else "Stopped" }}</strong>{% if running %} <small class="muted">(interval {{ interval }}s)</small>{% endif %}</p>

<section>
  <form action="/start" method="post" style="display:inline-block;">
    <label>‚è± Interval (s): <input type="number" name="interval" min="1" value="{{ interval }}" style="width:6rem;"></label>
    <button type="submit">‚ñ∂Ô∏è Start</button>
  </form>
  <form action="/stop" method="post" style="display:inline-block;">
    <button type="submit">‚èπ Stop</button>
  </form>
  <form action="/test-capture" method="get" style="display:inline-block;">
    <button type="submit">üì∏ Test Capture</button>
  </form>
  <form action="/last" method="get" style="display:inline-block;">
    <button type="submit">üñº View Last Image</button>
  </form>
  <form action="/cam-info" method="get" style="display:inline-block;">
    <button type="submit">üîé Camera Info</button>
  </form>
</section>

<section>
  <h2>‚è∞ Schedule</h2>
  <form action="/schedule" method="post">
    <div style="display:flex;flex-wrap:wrap;gap:.6rem;align-items:center;">
      <label>Start:
        <input type="datetime-local" name="start" required>
      </label>
      <label>End:
        <input type="datetime-local" name="end" required>
      </label>
      <label>Interval (s):
        <input type="number" name="interval" min="1" value="{{ interval }}" style="width:6rem;">
      </label>
      <label>üéû FPS:
        <select name="fps">
          {% for f in fps_choices %}
            <option value="{{ f }}" {% if f == default_fps %}selected{% endif %}>{{ f }}</option>
          {% endfor %}
        </select>
      </label>
      <button type="submit">üóì Arm Schedule</button>
    </div>
  </form>

  <div style="margin-top:.5rem;">
    <form action="/schedule/quick" method="post" style="display:inline-block;margin-right:.4rem;">
      <input type="hidden" name="interval" value="{{ interval }}">
      <input type="hidden" name="fps" value="{{ default_fps }}">
      <button type="submit">‚ö°Ô∏è Quick Test (1m ‚Üí +5m)</button>
    </form>
    <form action="/schedule/cancel" method="post" style="display:inline-block;">
      <button type="submit">‚úñÔ∏è Cancel Schedule</button>
    </form>
    <span style="margin-left:.6rem;">
      {% if schedule %}
        <small class="muted">Status: {{ schedule.status }} | Starts: {{ schedule.start_human }} | Ends: {{ schedule.end_human }} | FPS: {{ schedule.fps }}</small>
      {% else %}
        <small class="muted">No schedule armed.</small>
      {% endif %}
    </span>
  </div>
</section>

<section>
  <h2>üóÇ Sessions</h2>
  {% for s in sessions %}
    <div class="session" id="sess-{{ s.name }}">
      <h3>{{ s.name }} {% if current == s.name %}<small class="muted">(current)</small>{% endif %}</h3>

      {% if s.has_images %}
        <img class="thumb" src="/session/{{ s.name }}/preview?ts={{ loop.index }}" alt="preview of {{ s.name }}">
      {% elif current == s.name %}
        <div style="width:240px;height:180px;display:flex;align-items:center;justify-content:center;border:1px dashed #bbb;border-radius:8px;color:#666;">
          üì∑ capturing‚Ä¶
        </div>
      {% endif %}

      <div style="margin-top:.5rem;">
        <form action="/session/{{ s.name }}/video" method="post" style="display:inline-block;">
          <label>üéû FPS:
            <select name="fps">
              {% for f in fps_choices %}
                <option value="{{ f }}" {% if f == default_fps %}selected{% endif %}>{{ f }}</option>
              {% endfor %}
            </select>
          </label>
          <button type="submit" {% if not s.has_images %}disabled title="No images yet"{% endif %}>üé¨ Create Video</button>
        </form>
        {% if s.has_video %}
          <a class="btn" href="/session/{{ s.name }}/download">‚¨áÔ∏è Download Video</a>
        {% endif %}
      </div>

      <div class="job-status" data-sid="{{ s.name }}">
        {% if video_jobs.get(s.name) %}
          {% set job = video_jobs[s.name] %}
          {% if job.status == "running" %}
            <div class="progress"><div style="width: {{ job.progress }}%"></div></div>
            <small class="muted">Encoding at {{ job.fps }} fps‚Ä¶ {{ job.progress }}%</small>
          {% elif job.status == "done" %}
            <small class="muted">‚úÖ Video ready ({{ job.fps }} fps)</small>
          {% elif job.status == "error" %}
            <small class="muted">‚ùå {{ job.get("msg","Error") }}</small>
          {% endif %}
        {% endif %}
      </div>

      <form class="rename" action="/session/{{ s.name }}/rename" method="post" style="margin-top:.6rem;">
        <label>‚úèÔ∏è Rename:
          <input type="text" name="new_name" value="{{ s.name }}" {% if current == s.name %}disabled title="Stop capture to rename"{% endif %}>
        </label>
        <button type="submit" {% if current == s.name %}disabled{% endif %}>Save</button>
      </form>

      <form action="/session/{{ s.name }}/delete" method="post" onsubmit="return confirm('Delete this session?');" style="margin-top:.4rem;">
        <button type="submit" {% if current == s.name %}disabled title="Stop capture first"{% endif %}>üóë Delete Session</button>
      </form>
    </div>
  {% endfor %}
</section>

<script>
async function pollJobs() {
  try {
    const r = await fetch('/jobs');
    const data = await r.json();
    for (const sid in data) {
      const container = document.querySelector('.job-status[data-sid="'+sid+'"]');
      if (!container) continue;
      const j = data[sid];
      if (j.status === "running") {
        container.innerHTML =
          '<div class="progress"><div style="width:'+j.progress+'%"></div></div>' +
          '<small class="muted">Encoding at '+j.fps+' fps‚Ä¶ '+j.progress+'%</small>';
      } else if (j.status === "done") {
        container.innerHTML = '<small class="muted">‚úÖ Video ready ('+j.fps+' fps)</small>';
      } else if (j.status === "error") {
        container.innerHTML = '<small class="muted">‚ùå '+(j.msg||"Error")+'</small>';
      }
    }
  } catch(e) { /* ignore */ }
}
setInterval(pollJobs, 2000);
</script>

</body></html>
"""

# --- Routes ---
@app.route("/")
def index():
    load_schedule()
    sch = None
    if _schedule:
        sch = dict(_schedule)
        sch["start_human"] = time.strftime("%Y-%m-%d %H:%M", time.localtime(sch["start"]))
        sch["end_human"]   = time.strftime("%Y-%m-%d %H:%M", time.localtime(sch["end"]))
    return render_template_string(
        INDEX_HTML,
        running=_timelapse_running,
        interval=_interval_sec,
        sessions=session_meta(),
        current=current_session_name(),
        video_jobs=_video_jobs,
        fps_choices=FPS_CHOICES,
        default_fps=DEFAULT_FPS,
        schedule=sch
    )

@app.get("/jobs")
def jobs_status():
    return jsonify(_video_jobs)

@app.post("/start")
def web_start():
    try:
        interval = int(request.form.get("interval", CAPTURE_INTERVAL_SEC))
    except Exception:
        interval = CAPTURE_INTERVAL_SEC
    start_timelapse(interval)
    return redirect(url_for("index"))

@app.post("/stop")
def web_stop():
    stop_timelapse()
    return redirect(url_for("index"))

@app.get("/last")
def last_image():
    sess = list_sessions()
    if not sess: return "<p>No sessions.</p>"
    imgs = session_images(os.path.join(SESSIONS_DIR, sess[-1]))
    if not imgs: return "<p>No images in last session.</p>"
    return send_file(imgs[-1], mimetype="image/jpeg")

@app.get("/test-capture")
def test_cap():
    tmp = os.path.join(IMAGES_DIR, "test.jpg")
    r = capture_one(tmp, timeout=15)
    if r.returncode != 0:
        return "<pre>" + html.escape(r.stderr or "capture failed") + "</pre>", 500
    return send_file(tmp, mimetype="image/jpeg")

@app.get("/cam-info")
def cam_info():
    try:
        res = subprocess.run([CAMERA_HELLO, "--list-cameras"], capture_output=True, text=True, timeout=8)
        out = res.stdout or ""
        err = res.stderr or ""
        pinfo = f"STILL: {CAMERA_STILL}\nHELLO: {CAMERA_HELLO}\n"
        return "<pre>" + html.escape(pinfo + out + ("\nERR:\n" + err if err else "")) + "</pre>"
    except Exception as e:
        return f"<pre>Failed to run camera info: {html.escape(str(e))}</pre>", 500

@app.get("/session/<sid>/preview")
def session_preview(sid):
    path = os.path.join(SESSIONS_DIR, sid)
    if not os.path.isdir(path): abort(404)
    imgs = session_images(path)
    if not imgs: abort(404)
    return send_file(imgs[-1], mimetype="image/jpeg")

@app.post("/session/<sid>/video")
def session_video(sid):
    path = os.path.join(SESSIONS_DIR, sid)
    if not os.path.isdir(path): abort(404)
    try:
        fps = int(request.form.get("fps", DEFAULT_FPS))
    except Exception:
        fps = DEFAULT_FPS
    if fps not in FPS_CHOICES:
        fps = DEFAULT_FPS
    job = _video_jobs.get(sid)
    if job and job.get("status") == "running":
        return redirect(url_for("index"))
    threading.Thread(target=ffmpeg_create_video, args=(sid, path, fps), daemon=True).start()
    return redirect(url_for("index"))

@app.get("/session/<sid>/download")
def session_download(sid):
    f = os.path.join(SESSIONS_DIR, sid, "timelapse.mp4")
    if not os.path.exists(f): abort(404)
    return send_file(f, as_attachment=True, mimetype="video/mp4")

@app.post("/session/<sid>/rename")
def session_rename(sid):
    if current_session_name() == sid:
        return "<p>Stop capture before renaming this session.</p><p><a href='/'>Back</a></p>", 400
    src = os.path.join(SESSIONS_DIR, sid)
    if not os.path.isdir(src): abort(404)
    new_name = unique_session_name(safe_session_name(request.form.get("new_name", "")))
    dst = os.path.join(SESSIONS_DIR, new_name)
    try:
        os.rename(src, dst)
    except Exception as e:
        return f"<p>Rename failed: {html.escape(str(e))}</p><p><a href='/'>Back</a></p>", 500
    if sid in _video_jobs:
        _video_jobs[new_name] = _video_jobs.pop(sid)
    return redirect(url_for("index"))

@app.post("/session/<sid>/delete")
def session_delete(sid):
    if current_session_name() == sid:
        return "<p>Stop capture before deleting this session.</p><p><a href='/'>Back</a></p>", 400
    path = os.path.join(SESSIONS_DIR, sid)
    if not os.path.isdir(path): abort(404)
    for f in glob.glob(os.path.join(path, "*")):
        try: os.remove(f)
        except Exception: pass
    try: os.rmdir(path)
    except Exception: pass
    _video_jobs.pop(sid, None)
    return redirect(url_for("index"))

# --- Schedule endpoints ---
@app.post("/schedule")
def schedule_set():
    start_str = request.form.get("start")
    end_str   = request.form.get("end")
    try:
        interval = int(request.form.get("interval", CAPTURE_INTERVAL_SEC))
    except Exception:
        interval = CAPTURE_INTERVAL_SEC
    try:
        fps = int(request.form.get("fps", DEFAULT_FPS))
    except Exception:
        fps = DEFAULT_FPS
    if fps not in FPS_CHOICES:
        fps = DEFAULT_FPS

    def parse_dt(s):
        for fmt in ("%Y-%m-%dT%H:%M", "%Y-%m-%dT%H:%M:%S"):
            try:
                return int(time.mktime(time.strptime(s, fmt)))
            except Exception:
                pass
        raise ValueError(f"Bad datetime: {s}")

    try:
        start_ts = parse_dt(start_str)
        end_ts   = parse_dt(end_str)
        if end_ts <= start_ts:
            return "<p>End must be after start.</p><p><a href='/'>Back</a></p>", 400
        with _schedule_lock:
            global _schedule
            _schedule = {
                "start": start_ts,
                "end": end_ts,
                "interval": max(1, int(interval)),
                "fps": fps,
                "status": "armed",
                "session": None,
            }
            save_schedule()
        print(f"[SCHED] armed: start={start_ts} end={end_ts} interval={interval}s fps={fps}")
        return redirect(url_for("index"), code=303)
    except Exception as e:
        print("[SCHED][ERROR]", e)
        return f"<p>Schedule error: {html.escape(str(e))}</p><p><a href='/'>Back</a></p>", 400

@app.post("/schedule/quick")
def schedule_quick():
    """Arm a quick test: starts in 1 minute, runs 5 minutes."""
    try:
        interval = int(request.form.get("interval", CAPTURE_INTERVAL_SEC))
    except Exception:
        interval = CAPTURE_INTERVAL_SEC
    try:
        fps = int(request.form.get("fps", DEFAULT_FPS))
    except Exception:
        fps = DEFAULT_FPS
    if fps not in FPS_CHOICES:
        fps = DEFAULT_FPS

    now = int(time.time())
    start_ts = now + 60
    end_ts   = start_ts + 5*60

    with _schedule_lock:
        global _schedule
        _schedule = {
            "start": start_ts,
            "end": end_ts,
            "interval": max(1, int(interval)),
            "fps": fps,
            "status": "armed",
            "session": None,
        }
        save_schedule()
    print(f"[SCHED] quick armed: start={start_ts} end={end_ts} interval={interval}s fps={fps}")
    return redirect(url_for("index"), code=303)

@app.post("/schedule/cancel")
def schedule_cancel():
    with _schedule_lock:
        global _schedule
        if _schedule and _schedule.get("status") in ("armed","running","encoding"):
            _schedule["status"] = "canceled"
            save_schedule()
        else:
            _schedule = None
            save_schedule()
    return redirect(url_for("index"))

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5050)
